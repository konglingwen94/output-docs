<!DOCTYPE html><!-- saved from url=(0049)http://www.kiscon.top/knowledge/vue2-to-vue3.html --><html lang="en-US" class=" "><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
    <title>Vue3 的正确打开方式 | 前端文档</title>
    
    
    
    
    
    
  <meta name="description" content="Front end documentation"><link rel="stylesheet" href="../style.css"></head>
  <body>
    <div id="app"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="http://www.kiscon.top/" class="home-link router-link-active"><!----> <span class="site-name">前端文档</span></a> <div class="links" style="max-width: 2361px;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value="" class="" placeholder=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="http://www.kiscon.top/knowledge/com-design.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="http://www.kiscon.top/solution/plane.html" class="nav-link">
  解决方案
</a></div><div class="nav-item"><a href="http://www.kiscon.top/standard/base.html" class="nav-link">
  规范
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="http://www.kiscon.top/knowledge/com-design.html" class="nav-link">
  知识库
</a></div><div class="nav-item"><a href="http://www.kiscon.top/solution/plane.html" class="nav-link">
  解决方案
</a></div><div class="nav-item"><a href="http://www.kiscon.top/standard/base.html" class="nav-link">
  规范
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>知识库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items" style=""><li><a href="./组件设计.html" class="sidebar-link">组件设计</a></li><li><a href="./监控平台.html" class="sidebar-link">监控平台</a></li><li><a href="./Web安全.html" class="sidebar-link">Web安全</a></li><li><a href="./Webpack.html" class="sidebar-link">Webpack</a></li><li><a href="./Webpack原理.html" class="sidebar-link">Webpack原理</a></li><li><a href="./Webpack5+.html" class="sidebar-link">Webpack5+</a></li><li><a href="./ES7-12系列.html" class="sidebar-link">ES7-12系列</a></li><li><a href="./脚手架.html" class="sidebar-link">脚手架</a></li><li><a href="./Promise.html" class="sidebar-link">Promise</a></li><li><a href="./Git管控.html" class="sidebar-link">Git管控</a></li><li><a href="./零碎知识.html" class="sidebar-link">零碎知识</a></li><li><a href="./正则.html" class="sidebar-link">正则</a></li><li><a href="./布局方式.html" class="sidebar-link">布局方式</a></li><li><a href="./Require解读.html" class="sidebar-link">Require解读</a></li><li><a href="./BFC与IFC.html" class="sidebar-link">BFC与IFC</a></li><li><a href="./React技术栈.html" class="sidebar-link">React技术栈</a></li><li><a href="./Vue3与Vue2的区别.html" class="active sidebar-link" aria-current="page">Vue3与Vue2的区别</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#vue2-%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%83%BD%E5%90%A6%E7%9B%B4%E6%8E%A5%E5%8D%87%E7%BA%A7-vue3-%E5%91%A2" class="sidebar-link">Vue2 的项目能否直接升级 Vue3 呢</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="sidebar-link">消失的生命周期</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-listeners" class="sidebar-link">消失的$listeners</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-vue-prototype" class="sidebar-link">消失的 Vue.prototype</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" class="sidebar-link">消失的实例属性</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4" class="sidebar-link">消失的特殊指令</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-observable" class="sidebar-link">消失的 observable</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E8%BF%87%E6%B8%A1-class" class="sidebar-link">消失的过渡 class</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E4%BA%8B%E4%BB%B6-api" class="sidebar-link">消失的事件 API</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-hook" class="sidebar-link">消失的@hook</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-filter" class="sidebar-link">消失的 filter</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-productiontip" class="sidebar-link">消失的 productionTip</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-extend" class="sidebar-link">消失的 extend</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-config-keycodes" class="sidebar-link">消失的 config.keyCodes</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-propsdata" class="sidebar-link">消失的 propsData</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF-inline-template" class="sidebar-link">消失的内联模板 inline-template</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8C%96" class="sidebar-link">函数式组件的变化</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0-h-%E7%9A%84%E5%8F%98%E5%8C%96" class="sidebar-link">渲染函数  的变化</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%A2%9E%E5%BC%BA%E7%9A%84-ref" class="sidebar-link">增强的 ref</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E-defineasynccomponent" class="sidebar-link">新增 defineAsyncComponent</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8F%98%E5%8C%96" class="sidebar-link">自定义指令的变化</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#data-%E9%80%89%E9%A1%B9%E7%9A%84%E5%8F%98%E5%8C%96" class="sidebar-link">data 选项的变化</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E-emits-%E9%80%89%E9%A1%B9" class="sidebar-link">新增 emits 选项</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E-fragments" class="sidebar-link">新增 fragments</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#key-%E5%B1%9E%E6%80%A7%E7%9A%84%E9%9D%9E%E5%BF%85%E9%9C%80%E6%80%A7" class="sidebar-link">key 属性的非必需性</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E4%BC%98%E5%8C%96%E7%89%88%E7%9A%84-mount" class="sidebar-link">优化版的$mount</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%BC%BA%E5%8C%96%E7%89%88%E7%9A%84-v-model" class="sidebar-link">强化版的 v-model</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#v-if-%E5%92%8C-v-for-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E6%95%B4" class="sidebar-link">v-if 和 v-for 的优先级调整</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%A2%9E%E5%BC%BA%E7%9A%84-v-bind" class="sidebar-link">增强的 v-bind</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E%E5%93%8D%E5%BA%94%E5%BC%8F-api" class="sidebar-link">新增响应式 API</a></li><li class="sidebar-sub-header"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E%E7%BB%84%E5%90%88%E5%BC%8F-api" class="sidebar-link">新增组合式 API</a></li></ul></li><li><a href="./移动web.html" class="sidebar-link">移动web</a></li><li><a href="./HTTP状态码.html" class="sidebar-link">HTTP状态码</a></li><li><a href="./HTTP缓存.html" class="sidebar-link">HTTP缓存</a></li><li><a href="./事件循环与多进程.html" class="sidebar-link">事件循环与多进程</a></li><li><a href="./Rollup模块打包器.html" class="sidebar-link">Rollup模块打包器</a></li><li><a href="./小程序.html" class="sidebar-link">小程序</a></li><li><a href="./Vue3与Webpack5.html" class="sidebar-link">Vue3与Webpack5</a></li><li><a href="./Lottie动画解析.html" class="sidebar-link">Lottie动画解析</a></li><li><a href="./Axios核心源码解析.html" class="sidebar-link">Axios核心源码解析</a></li><li><a href="./Typescript应用.html" class="sidebar-link">Typescript应用</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>解决方案</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>规范</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue3-的正确打开方式"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#vue3-%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F" class="header-anchor">#</a> Vue3 的正确打开方式</h1> <p>Vue3 已经出道了 3.2 版本了，但是目前 Vue3 的普及程度还是远不如 Vue2;但是 Vue3 的学习却是已经刻不容缓了；Vue2 的项目能否直接升级 Vue3 呢？那么 Vue2 到 Vue3 消失了那些 API？Vue3 新增或增强的 API 呢？</p> <h2 id="vue2-的项目能否直接升级-vue3-呢"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#vue2-%E7%9A%84%E9%A1%B9%E7%9B%AE%E8%83%BD%E5%90%A6%E7%9B%B4%E6%8E%A5%E5%8D%87%E7%BA%A7-vue3-%E5%91%A2" class="header-anchor">#</a> Vue2 的项目能否直接升级 Vue3 呢</h2> <p>Vue2 的项目不能直接升级 Vue3；因为 Vue3 对 Vue2 并不是全兼容的；但是如果你把 Vue3 当成 Vue2 来使用也是没有问题的(只是用来做一些简单数据渲染，状态绑定)；</p> <h1 id="消失的-api"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-api" class="header-anchor">#</a> 消失的 API</h1> <h2 id="消失的生命周期"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="header-anchor">#</a> 消失的生命周期</h2> <ol><li><b>beforeDestroy</b> --&gt; <b>beforeUnmount</b></li> <li><b>destroyed</b> --&gt; <b>unmounted</b></li></ol> <p>从官方文档上看，这两个钩子有啥区别，不知道为什么要换名字；</p> <p>既然没有了<i style="color: rgb(62, 175, 124);">destroyed</i>,那么自然在实例中就不存在<span style="color: rgb(62, 175, 124); font-style: italic;">$destroy</span>方法了；以后再也不能愉快的手动销毁组件了；</p> <h2 id="消失的-listeners"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-listeners" class="header-anchor">#</a> 消失的$listeners</h2> <p>不得不说<span style="color: rgb(62, 175, 124); font-style: italic;">$attrs</span>, <span style="color: rgb(62, 175, 124); font-style: italic;">$listener</span>的出现是 Vue2 的以一大进步，在早期开发中还没有<span style="color: rgb(62, 175, 124); font-style: italic;">$attrs</span>, <span style="color: rgb(62, 175, 124); font-style: italic;">$listener</span>的时候，只要做组件的封装不得不吐槽 Vue2 的呆板，跟 react 相比，只能说 react 的全属性继承，全事件透传是真香；</p> <p>Vue3 中<span style="color: rgb(62, 175, 124); font-style: italic;">$listener</span>已经被遗弃；但是Vue3并没有放弃全事件透传的能力；反而更加向react靠拢，书写起来更方便，更简单；将$listeners 的与$attrs合并；以后再不用组件上使用<span style="color: rgb(62, 175, 124); font-style: italic;"><b>v-on="$listeners"</b></span>了；来看一下代码的区别；</p> <p>Vue2 中：</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token comment">&lt;!-- 父组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:placeholder"请输入"</span> <span class="token attr-name">:max-length</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>changeHandler<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 子组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-input</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$attrs<span class="token punctuation">"</span></span> <span class="token attr-name">v-on</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$listeners<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-input</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>Vue3</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:placeholder"请输入"</span> <span class="token attr-name">:max-length</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>10<span class="token punctuation">"</span></span> <span class="token attr-name">@change</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>changeHandler<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!-- 子组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-input</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>$attrs<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-input</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>Vue3
当需要透传的属性是动态的时候：</p> <div class="language-vue extra-class"><pre class="language-vue"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child</span> <span class="token attr-name">:attrs</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>attrs<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">placeholde</span><span class="token operator">:</span> <span class="token string">'请输入'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">maxLength</span><span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
        <span class="token literal-property property">onChange</span><span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>changeHandler
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">changeHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- 子组件 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-input</span> <span class="token attr-name">v-bind</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>attrs<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-input</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">attrs</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">type</span><span class="token operator">:</span> Object<span class="token punctuation">,</span>
      <span class="token function-variable function">default</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">重点</p> <p>当事件作为属性透传的时候<b>一定，必须是以 on 开头</b>，接事件名称</p></div> <h2 id="消失的-vue-prototype"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-vue-prototype" class="header-anchor">#</a> 消失的 Vue.prototype</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createApp <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createApp</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>Vue3 中，不再支持在 Vue.prototype 上绑定全局属性；</p> <ol><li>Vue3 中的 Vue 不再是一个函数，而是一个对象</li> <li><span style="color: rgb(62, 175, 124);"><strong><em>createApp</em></strong></span> 函数返回的是一个 VueComponent 对象, 对象不存在 prototype 属性, 所以也不能在 <span style="color: rgb(62, 175, 124);"><strong><em>createApp</em></strong></span>函数返回的对象的原型链上绑定全局属性</li> <li>Vue 组件中的<span style="color: rgb(62, 175, 124);"><strong><em>this</em></strong></span>对象任然保留 Vue 自定义全局属性，例如（$attrs, $nextTick, $set......）</li></ol> <p>Vue3 中提供了一个全局对象配置 <strong><em>app.config.globalProperties</em></strong>，需要挂载到全局的属性可以放在这个全局对象上；挂载到全局对象上的属性可以再组件内部通过<code>this</code>访问；</p> <div class="custom-block warning"><p class="custom-block-title">提示</p> <p><b>setup</b>函数中不存在<b>this</b>对象, 在 setup 中想要获取实例，请使用 <strong><em>getCurrentInstance</em></strong> 方法，该方法返回组件实例；</p></div> <h2 id="消失的实例属性"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" class="header-anchor">#</a> 消失的实例属性</h2> <ol><li>$children</li> <li>$scopedSlots</li> <li>$isServer</li> <li>$listeners</li></ol> <h2 id="消失的特殊指令"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E7%89%B9%E6%AE%8A%E6%8C%87%E4%BB%A4" class="header-anchor">#</a> 消失的特殊指令</h2> <ol><li>slot</li> <li>slot-scope</li> <li>scope</li></ol> <p>总结一句话就是 Vue3 <strong><em>废除作用域插槽，具名插槽</em></strong>；仅支持 <strong><em>v-slot</em></strong>; <strong><em>v-slot</em></strong> 仅限用于 template 组件，且组件仅能只有 <strong><em>v-slot</em></strong> 这一个属性；</p> <h2 id="消失的-observable"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-observable" class="header-anchor">#</a> 消失的 observable</h2> <p><span style="color: rgb(62, 175, 124);"><strong><em>observable</em></strong></span>最早出现在 2.6 的版本中；主要用于做全局响应式数据的存储，在普通的项目中，如果全局响应式的数据不是很多的情况是可以不必要使用 vuex， 用 <strong><em>observable</em></strong> 即可；用法跟 vuex 差不多，简单易用；</p> <p>在 Vue3 中，Vue3 提供了更为强大的相应 API <span style="color: rgb(62, 175, 124);"><strong><em>reactive</em></strong></span>, 用法跟 <strong><em>observable</em></strong> 一样;</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// sotre.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">username</span><span class="token operator">:</span> <span class="token string">'town'</span><span class="token punctuation">,</span>
  <span class="token literal-property property">token</span><span class="token operator">:</span> <span class="token string">'TK23423423'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token parameter">payload</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">.</span>username <span class="token operator">=</span> payload
<span class="token punctuation">}</span>
<span class="token comment">// 组建中使用store</span>

<span class="token keyword">import</span> <span class="token punctuation">{</span> state<span class="token punctuation">,</span> setName <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./store.js'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">computed</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">username</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>username
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">setUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">'town2021'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="消失的过渡-class"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E8%BF%87%E6%B8%A1-class" class="header-anchor">#</a> 消失的过渡 class</h2> <ol><li><code>.v-enter</code> --&gt; <code>.v-enter-from</code></li> <li><code>.v-leave</code> --&gt; <code>.v-leave-from</code><div class="custom-block warning"><p class="custom-block-title">重点</p> <p><code>transiton</code>，<code>transition-group</code>可以作为根节点; <code>transition-group</code>不再默认渲染根元素；</p></div></li></ol> <h2 id="消失的事件-api"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E4%BA%8B%E4%BB%B6-api" class="header-anchor">#</a> 消失的事件 API</h2> <ol><li>$on</li> <li>$once</li> <li>$off</li></ol> <div class="custom-block warning"><p class="custom-block-title">提示</p> <p>原生事件修饰符<code>.native</code>被移除</p></div> <h2 id="消失的-hook"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-hook" class="header-anchor">#</a> 消失的@hook</h2> <p><span style="color: rgb(62, 175, 124);"><strong><em>@hook</em></strong></span>是一个组件生命周期监听器，该属性的出现主要是为了方便在父组件，更优雅的监听子组件的生命周期钩子的触发，当然也可以用于在组件中监听自身生命周期钩子的触发；</p> <p>Vue3 中不再支持<code>@hook</code>, 而是提供了能力更为强大的<code>@vnode-</code>; 该属性不仅可以作用于组件上，也可作用于 HTML 元素上；但是遗憾的是因为没有了<code>$on</code>和<code>$once</code>，<code>@vnode-</code>估计只能作用于 template 中，无法在组件生命周期钩子以及 methods 中使用；</p> <h2 id="消失的-filter"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-filter" class="header-anchor">#</a> 消失的 filter</h2> <p><span style="color: rgb(62, 175, 124);"><strong><em>filter</em></strong></span>在 Vue3 中已经被移除，无论是局部 filter 还是全局 filter 都不支持；局部建议使用计算属性或者方法来替换，全局兼用将 filter 方法挂载到<code>app.config.globalProperties</code>上；</p> <h2 id="消失的-productiontip"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-productiontip" class="header-anchor">#</a> 消失的 productionTip</h2> <p>对于 ES 模块构建，由于它们是与 bundler 一起使用的，而且在大多数情况下，CLI 或样板已经正确地配置了生产环境，所以本技巧将不再出现</p> <h2 id="消失的-extend"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-extend" class="header-anchor">#</a> 消失的 extend</h2> <p>组件继承在 Vue3 中不被建议，Vue3 建议使用组合式 API 来替代继承和 mixin; 如果一定要使用基础，那么官方提供了<code>extends</code>属性；</p> <p>如果使用 extend 来创建组件，Vue3 中将使用<code>creatApp</code>来替代；</p> <h2 id="消失的-config-keycodes"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-config-keycodes" class="header-anchor">#</a> 消失的 config.keyCodes</h2> <p>Vue2 中可以通过<code>config.keyCodes</code>来配置键盘的按键事件；从<code>KeyboardEvent.keyCode</code> <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/KeyboardEvent/keyCode" target="_blank" rel="noopener noreferrer">has been deprecated<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 开始，Vue 3 继续支持这一点就不再有意义了。因此，现在建议对任何要用作修饰符的键使用 kebab-cased (短横线) 大小写名称;</p> <div class="custom-block warning"><p class="custom-block-title">提示</p> <p>Vue3 不再支持使用数字作为<code>v-on</code>修饰符</p></div> <h2 id="消失的-propsdata"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84-propsdata" class="header-anchor">#</a> 消失的 propsData</h2> <p><code>propsData</code> 选项在 Vue2 中用于创建 vue 实例的过程中传入 prop,在 Vue3 中被移除；如果想在创建实例的时候传入 prop，需在<span style="color: rgb(62, 175, 124);"><strong><em>createApp</em></strong></span>函数中出入第二参数;</p> <h2 id="消失的内联模板-inline-template"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B6%88%E5%A4%B1%E7%9A%84%E5%86%85%E8%81%94%E6%A8%A1%E6%9D%BF-inline-template" class="header-anchor">#</a> 消失的内联模板 inline-template</h2> <p>什么是 inline-template：以便将自定义组件内部内容用作模板，而不是将其作为分发内容；</p> <p><b>基本用不上，可以忽略，使用该属性的人基本上是闲得无聊的;</b></p> <h2 id="函数式组件的变化"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%98%E5%8C%96" class="header-anchor">#</a> 函数式组件的变化</h2> <ol><li>函数式组件不再必须<code>functional</code>属性，可以是一个纯函数</li> <li>函数式组件接收两个参数<code>props</code> <code>context</code>;(context = {slots, attrs, emit})，跟<code>setup</code>函数一样;</li> <li>需要显式的引入 <strong><em>h</em></strong> 函数（<code>import { h } from 'vue'</code>）；</li> <li>函数式组件依然支持 Vue 的写法，只不过 render 函数发生了一点点的变化</li></ol> <p>Vue3 中使用函数式组件的两种方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 纯函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">createDynamicCom</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">,</span> <span class="token punctuation">{</span> slots<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> emit <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> slots<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// functional声明</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> h <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">functional</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token comment">// render不再接收 h函数</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>attrs<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>slots<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong><em>render 函数</em></strong> 接收 6 个参数，但是仅第一个参数有使用价值，且第一个参数的值安全等于 <strong><em>this</em></strong> 对象；所以一般我们直接使用 <strong><em>this</em></strong> 就行;一起来看看 <strong><em>this</em></strong> 对象有哪些属性；</p> <img src="./Vue3 的正确打开方式 _ 前端文档_files/render.this.png"> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token literal-property property">$</span><span class="token operator">:</span> Object <span class="token comment">// app实例</span>
  <span class="token literal-property property">$attrs</span><span class="token operator">:</span> Proxy <span class="token comment">// 组件的attribute</span>
  <span class="token literal-property property">$data</span><span class="token operator">:</span> Object <span class="token comment">// 当前组件的data数据</span>
  <span class="token literal-property property">$el</span><span class="token operator">:</span> HTMLELement <span class="token comment">// 当前组件的dom实例</span>
  <span class="token function-variable function">$emit</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token comment">// 触发emit时间的函数</span>
  <span class="token function-variable function">$forceUpdate</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token comment">// 强制更新组件函数</span>
  $nextTick：<span class="token keyword">function</span>
  $options： Object <span class="token comment">// 自身组件的对象数据，</span>
  <span class="token literal-property property">$parent</span><span class="token operator">:</span> Proxy <span class="token comment">// 父组件的引用对象，</span>
  <span class="token literal-property property">$props</span><span class="token operator">:</span> Proxy <span class="token comment">// 显式在组件的props属性中生命的props对象</span>
  <span class="token literal-property property">$refs</span><span class="token operator">:</span> Proxy <span class="token comment">// 当前组件的ref</span>
  <span class="token literal-property property">$root</span><span class="token operator">:</span> Proxy <span class="token comment">// vue实例根节点</span>
  <span class="token literal-property property">$slots</span><span class="token operator">:</span> Proxy <span class="token comment">// 当前组件的插槽</span>
  <span class="token function-variable function">$watch</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token comment">// 监听函数</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">重点</p> <p>$parent 不再是当前函数式组件的父级组件，而是包裹当前函数式组件的 dom 或者自定义组件，这是跟 Vue2 不同的地方, 使用的时候请谨慎；</p></div> <h2 id="渲染函数-h-的变化"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0-h-%E7%9A%84%E5%8F%98%E5%8C%96" class="header-anchor">#</a> 渲染函数 <code>h</code> 的变化</h2> <p><code>h</code>函数不再能够根据组件名来渲染全局注册的组件；仅支持渲染 dom 标签，以及被加载的组件；</p> <p>Vue2 中使用 h 函数渲染全局组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'el-input'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Vue3 中使用 h 函数渲染全局组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> resolveComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token keyword">const</span> ELInput <span class="token operator">=</span> <span class="token function">resolveComponent</span><span class="token punctuation">(</span><span class="token string">'el-input'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ELInput<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Vue3 中使用 h 函数渲染非全局组件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> ELinput <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'element-ui'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">components</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    ELinput
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>ELInput<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h1 id="新增或增强的-api"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E%E6%88%96%E5%A2%9E%E5%BC%BA%E7%9A%84-api" class="header-anchor">#</a> 新增或增强的 API</h1> <h2 id="增强的-ref"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%A2%9E%E5%BC%BA%E7%9A%84-ref" class="header-anchor">#</a> 增强的 ref</h2> <p><tag>ref</tag> 是一个组件或者 dom 的引用，Vue2 中，ref 一般是一个字符串；当多个组件使用同一个 ref 的时候，<code>this.$refs[ref]</code> 将返回一个引用数组；
Vue3 中<tag>ref</tag> 可以是一个函数，函数接一个参数，改参数为绑定改 ref 的组件的实例；</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>item in list<span class="token punctuation">"</span></span> <span class="token attr-name">:ref</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>setItemRef<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">itemRefs</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token literal-property property">methods</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">setItemRef</span><span class="token punctuation">(</span><span class="token parameter">el</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>itemRefs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>itemRefs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">updated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>itemRefs<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="新增-defineasynccomponent"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E-defineasynccomponent" class="header-anchor">#</a> 新增 defineAsyncComponent</h2> <p>创建一个只有在需要时才会加载的异步组件; 可以接受一个返回 Promise 的工厂函数。Promise 的 resolve 回调应该在服务端返回组件定义后被调用。你也可以调用 reject(reason) 来表示加载失败;
如果仅仅是这样好像跟<code>() =&gt; import()</code>没什么区别；</p> <p>来看一下比较高阶的玩法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> defineAsyncComponent <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> asyncModalWithOptions <span class="token operator">=</span> <span class="token function">defineAsyncComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">loader</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./Modal.vue'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token literal-property property">delay</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span>
  <span class="token literal-property property">timeout</span><span class="token operator">:</span> <span class="token number">3000</span><span class="token punctuation">,</span>
  <span class="token literal-property property">errorComponent</span><span class="token operator">:</span> ErrorComponent<span class="token punctuation">,</span>
  <span class="token literal-property property">loadingComponent</span><span class="token operator">:</span> LoadingComponent
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="自定义指令的变化"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8F%98%E5%8C%96" class="header-anchor">#</a> 自定义指令的变化</h2> <p>指令生命周期的变化</p> <table><thead><tr><th>Vue2</th> <th>Vue3</th> <th>备注</th></tr></thead> <tbody><tr><td></td> <td>created</td> <td>新增</td></tr> <tr><td>bind</td> <td>beforeMount</td> <td></td></tr> <tr><td>inserted</td> <td>mounted</td> <td></td></tr> <tr><td></td> <td>beforeUpdate</td> <td>新的！这是在元素本身更新之前调用的，很像组件生命周期钩子</td></tr> <tr><td>update</td> <td></td> <td>移除！请改用 updated</td></tr> <tr><td>componentUpdated</td> <td>updated</td> <td>此处判断组件更新调用十分频繁，如需使用此钩子，一定要写明确的触发的判断条件</td></tr> <tr><td></td> <td>beforeUnmount</td> <td>新增！与组件生命周期钩子类似，它将在卸载元素之前调用。</td></tr> <tr><td>unbind</td> <td>unmounted</td> <td></td></tr></tbody></table> <p>访问组件实例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// vue2中</span>
<span class="token function">bind</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm <span class="token operator">=</span> vnode<span class="token punctuation">.</span>context
<span class="token punctuation">}</span>

<span class="token comment">// vue3中</span>
<span class="token function">mounted</span><span class="token punctuation">(</span><span class="token parameter">el<span class="token punctuation">,</span> binding<span class="token punctuation">,</span> vnode</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> vm <span class="token operator">=</span> binding<span class="token punctuation">.</span>instance
<span class="token punctuation">}</span>
</code></pre></div><h2 id="data-选项的变化"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#data-%E9%80%89%E9%A1%B9%E7%9A%84%E5%8F%98%E5%8C%96" class="header-anchor">#</a> data 选项的变化</h2> <p>如果你不是用<code>mixin</code>或者<code>extend</code>，那么 <tag>data</tag> 的变化你基本是不能感知的；因为 <tag>data</tag>的变化主要在他的多个 data 合并时的合并策略；当合并来自 <code>mixin</code> 或 <code>extend</code> 的多个 <tag>data</tag> 返回值时，现在是浅层次合并的而不是深层次合并的(只合并根级属性);</p> <p>这简单的一句话暴露了一个非常重大的问题；不了解的话很有可能就踩坑了；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// index.mixin.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 组件中</span>
<span class="token keyword">import</span> IndexMixin <span class="token keyword">from</span> <span class="token string">'./index.mixin.js'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">mixins</span><span class="token operator">:</span> <span class="token punctuation">[</span>IndexMixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
        <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Vue2合并后的结果</span>
<span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'jack'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// vue3合并后的结果</span>
<span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">userInfo</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">18</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="新增-emits-选项"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E-emits-%E9%80%89%E9%A1%B9" class="header-anchor">#</a> 新增 emits 选项</h2> <p><tag>emits</tag> 属性用法类似 props 属性；意在可以让开发者显式的定义该组件可以向父组件触发的事件；Vue2 中在触发 emits 的时候是不知道当前组件可以向父组件触发什么事件的；</p> <p>emits 可以是简单的数组，也可以是对象，后者允许配置事件验证；个人感觉在实际开发中并没有太大的用武之地；因为在向父组件触发事件的时候一般是手动，且目的，数据十分明确的状态下的；但是还是来一起看看如何配置验证函数；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">emits</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">click</span><span class="token operator">:</span> <span class="token parameter">payload</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>email <span class="token operator">&amp;&amp;</span> payload<span class="token punctuation">.</span>password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Invalid submit event payload!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>验证函数接收当前组件传递给父组件的参数作为参数；验证函数应返回布尔值，以表示事件参数是否有效；</p> <h2 id="新增-fragments"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E-fragments" class="header-anchor">#</a> 新增 fragments</h2> <p>组件支持多根节点，Vue2 中一个组件只能拥有一个根节点；</p> <h2 id="key-属性的非必需性"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#key-%E5%B1%9E%E6%80%A7%E7%9A%84%E9%9D%9E%E5%BF%85%E9%9C%80%E6%80%A7" class="header-anchor">#</a> key 属性的非必需性</h2> <p>对于 <code>v-if/v-else/v-else-if</code> 的各分支项 key 将不再是必须的，因为现在 Vue 会自动生成唯一的 <code>key</code>。
<code> template v-for </code> 的 <code>key</code> 应该设置在 <code>template</code> 标签上 (而不是设置在它的子节点上)，Vue2 中<code>template</code>不允许使用 <code>key</code>。</p> <h2 id="优化版的-mount"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E4%BC%98%E5%8C%96%E7%89%88%E7%9A%84-mount" class="header-anchor">#</a> 优化版的$mount</h2> <p>挂载的内容将作为挂载容器的<code>innerHTML</code>; 而非整个替换挂载容器；</p> <h2 id="强化版的-v-model"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%BC%BA%E5%8C%96%E7%89%88%E7%9A%84-v-model" class="header-anchor">#</a> 强化版的 v-model</h2> <p>v-model 不再特指 value，也不再特定使用 update 来触发；</p> <ol><li>现在可以在同一个组件上使用多个 v-model 进行双向绑定</li> <li>现在可以自定义 v-model 修饰符 <strong><em>（不建议使用，使用起来会让你的代码变得更引用，可读性更低；）</em></strong></li></ol> <h2 id="v-if-和-v-for-的优先级调整"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#v-if-%E5%92%8C-v-for-%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E6%95%B4" class="header-anchor">#</a> v-if 和 v-for 的优先级调整</h2> <p>Vue3 中 <code>v-if</code> 的优先级将高于 <code>v-for</code>; 真算是 Vue3 的一点点性能优化；但是还是不建议使用模板来做渲染逻辑处理，推荐使用计算属性来处理那些数据数据是否该被渲染；</p> <h2 id="增强的-v-bind"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E5%A2%9E%E5%BC%BA%E7%9A%84-v-bind" class="header-anchor">#</a> 增强的 v-bind</h2> <p>Vue2 中直接声明的 <b>attribute</b> 属性优先级高于 <code>v-bind</code> 中定义的属性；Vue3 中将会将直接生命的 <b>attribute</b> 与 <code>v-bind</code> 中的属性合并；优先级取决于直接声明的 <b>attribute</b> 是书写在 <code>v-bind</code> 的前面还是后面；也就是优先级由顺序决定，越往右优先级越高；</p> <h2 id="新增响应式-api"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E%E5%93%8D%E5%BA%94%E5%BC%8F-api" class="header-anchor">#</a> 新增响应式 API</h2> <ol><li><code>reactive</code></li> <li><code>readonly</code></li> <li><code>isProxy</code> --&gt; 检查对象是否是由 reactive 或 readonly 创建的 proxy</li> <li><code>isReactive</code> --&gt; 检查对象是否是由 reactive 创建的响应式代理</li> <li><code>isReadonly</code> --&gt; 检查对象是否是由 readonly 创建的只读代理</li> <li><code>toRow</code></li> <li><code>markRow</code></li> <li><code>shallowReactive</code></li> <li><code>shallowReadonly</code></li></ol> <h3 id="reactive"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#reactive" class="header-anchor">#</a> reactive</h3> <p><tag>reactive</tag> 简单来说就是用来定义响应式对象的；大部分情况我们在 <code>setup</code> 中把他充当 Vue2 中的 <code>data</code> 函数来使用的；只是 <tag>reactive</tag> 返回的响应式数据必须通过 <code>setup</code> 函数 return 出来; 对对象中的值为 <code>ref</code> 的属性自动解包；通过属性访问到的直接是值，而并非 <code>ref</code> 包；</p> <p>这里我们必须明确的是经过 <tag>reactive</tag> 函数处理之后返回的并不是传入的对象本身，而是返回了原始对象的响应式副本, <strong><em>且是深层次的代理，无论对象如何嵌套，所有属性都将被代理</em></strong>；所以后期你操作原始对象是不会触发视图更新的，但是数据会发生变化；</p> <div class="custom-block warning"><p class="custom-block-title">Tips</p> <p>在 <code><b>setup</b></code> 函数中, <code>return</code> 之前，无论你操作原始对象还是响应式副本，数据会更新，并将最新的数据作用于视图；此处不要产生误解，好像操作原始数据能更新页面视图；但是其实在页面视图渲染之前数据已经发生更新；</p></div> <p><b>问：更新原始数据之后，响应式副本的数据也已经发生了更新，那什么时候可以将更新的数据反应到视图上呢？</b></p> <p><b>答：下一次响应式副本数据更新的时候</b></p> <p>看到这是是不是觉得有点像 Vue2 中未产生响应式的状态</p> <blockquote><p>了解什么是响应式副本，我们先了解一个叫 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect" target="_blank" rel="noopener noreferrer">Reflect<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的特性；</p></blockquote> <h3 id="readonly"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#readonly" class="header-anchor">#</a> readonly</h3> <p><tag>readonly</tag> 顾名思义就是只读；被 readonly 处理过的无论是响应式对象还是响应式基础类型数据返回的都只是原始对象的只读代理，这种代理是深层次的；也就是不要妄想改变 readonly 处理过的数据；
所有对 readonly 代理过的数据进行操作的都被将收到警告；</p> <blockquote><p>赋值警告： <code>Set operation on key "${String(key)}" failed: target is readonly.</code></p></blockquote> <blockquote><p>删除属性警告： <code>Delete operation on key "${String(key)}" failed: target is readonly.</code></p></blockquote> <h3 id="torow"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#torow" class="header-anchor">#</a> toRow</h3> <p><tag>toRow</tag> 这个可以说是比较鸡肋的一个 API；主要作用就是返回 <code>reactive</code>, <code>readonly</code> 代理的原始对象；主要作用就是为了实现上面讲 <code>reactive</code> 提到的数据更新，视图不更新的场景；但是大部分时候呢它是作为一个优化的项来使用的；</p> <ol><li>在临时读取数据的时候，从经过 <code>toRow</code> 处理过的原始对象读取数据无需承担代理访问/跟踪的开销；</li> <li>在视图更新给紧急的时候，先做数据更新，等待所有数据处理完毕之后，将所有更新的数据进行一次性的更新，这样避免多次触发视图更新；</li></ol> <h3 id="markrow"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#markrow" class="header-anchor">#</a> markRow</h3> <p>在了解了 <code>toRow</code> 之后，看 <tag>markRow</tag> 的名称大概就能猜到了它的作用 --&gt; “标记一个对象，使其永远不会被转换成 proxy，返回对象本身”</p> <h3 id="shallowreactive"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#shallowreactive" class="header-anchor">#</a> shallowReactive</h3> <p><tag>shallowReactive</tag> 跟 <code>reactive</code> 一样，都是产生响应式副本，但是 <tag>shallowReactive</tag> <strong><em>产生的响应式副本却是浅层次</em></strong> ，而非像 reactive 那样深层次，它只对自身根属性产生响应式；不执行嵌套对象的深层响应式转化；对值为 <code>ref</code> 的属性并不会自动解包，通过属性访问到的依然是 <code>ref</code> 包；</p> <h3 id="shallowreadonly"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#shallowreadonly" class="header-anchor">#</a> shallowReadonly</h3> <p><tag>shallowReadonly</tag> 跟 <tag>shallowReactive</tag> 理解一样，只对对象自身的根属性产生只读影响，而不会执行嵌套对象的深度只读转换；对对象中值为 <code>ref</code> 的属性也不会产生只读效果，无论是不是根属性；其实这里也很好理解，<code>ref</code> 包裹后的基础类型数据也是一个对象；<tag>shallowReadonly</tag> 并不会自动将 <code>ref</code> 解包；</p> <h3 id="ref"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#ref" class="header-anchor">#</a> ref</h3> <p><tag>ref</tag> 跟 <code> reactive </code> 的作用一样，都是定义响应式数据的；既然功能类似为什么 Vue3 要提供两个 API 呢？</p> <p>虽然功能类似，但是还说区别的：</p> <ol><li><code>ref</code> 返回的响应式数据是一个 <code>ref</code> 对象;</li> <li><code>reactive</code> 返回的是一个 Proxy 数据；</li> <li><code>ref</code> 代理的数据必须通过 <code>ref</code> 对象的内部属性 <code>value</code> 访问，<code>value</code> 是一个 Proxy 数据；</li> <li><code>ref</code> 产生响应式数据的过程是先接受一个数据作为 <code>ref</code> 对象的内部属性 <code>value</code> 的值；然后对内部属性 <code>value</code> 做响应式处理；</li> <li><code>reactive</code> 是直接将接受到的对象做响应式处理，并返回一个响应式副本；</li> <li><code>ref</code> 可以用来代理引用数据；</li> <li><code>reactive</code> Vue3 不能用来代理基础类型数据, 直接返回原始值；</li></ol> <h4 id="说到这里"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E8%AF%B4%E5%88%B0%E8%BF%99%E9%87%8C" class="header-anchor">#</a> 说到这里：</h4> <p><b>问：为什么官方推荐基础类型的数据推荐使用 <code>ref</code> 而 引用类型数据推荐使用 <code>reactive</code> 呢？ </b></p> <p><b>答： Vue3 的 <code>Proxy</code> 只能为引用类型的数据提供代理服务, 无法为基础类型数据提供代理服务；</b></p> <p><b>问：为什么 <code>ref</code> 能将基础类型数据通过 <code>Proxy</code> 代理？</b></p> <p><b>答：<code>ref</code> 函数接收一个值，作为内部对象的 <code>value</code> 属性的值，返回的是一个 <code>ref</code> 对象；本质上就是将接收的值放到 <code>ref</code> 对象上，然后使用 <code>Proxy</code> 对 <code>ref</code> 对象进行代理；</b></p> <p><b>问：同样是引用类型数据 <code>ref</code> 和 <code>reactive</code> 如何取舍？</b></p> <p><b>答：如果你想对数据的每次更新都是重新赋值，那么建议使用 <code>ref</code>, 如果只是对对象的属性进行更新，那么建议使用 <code>reactive</code></b></p> <div class="custom-block warning"><p class="custom-block-title">重点</p> <ol><li>ref 不仅只能对基础类型数据做响应时代理</li> <li>reactive 一直只能对引用类型数据做响应式代理</li> <li>ref 代理的数据在 <strong><em>js</em></strong> 中访问必须通过 <code>.value</code> 访问，在模板中使用会自动解包，直接使用即可；</li> <li>基础类型数据：<code>string</code>，<code>number</code>，<code>boolean</code>，<code>bigint</code>，<code>null</code>，<code>undefined</code>，<code>symbol</code></li></ol></div> <h3 id="unref"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#unref" class="header-anchor">#</a> unRef</h3> <p>如果参数是一个 <code>ref</code>，则返回内部值，否则返回参数本身。这是 val = isRef(val) ? val.value : val 的语法糖函数;</p> <h3 id="toref"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#toref" class="header-anchor">#</a> toRef</h3> <p>可以用来为源响应式对象上的某个 property 新创建一个 <code>ref</code>。然后，<code>ref</code> 可以被传递，它会保持对其源 property 的响应式连接。
白话将就是可以将响应式对象中的某个属性结构出来，并且这个属性还将与响应式对象保持响应式链接，不会因为被解构而失去响应式；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">1</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span>
a<span class="token operator">++</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><h3 id="torefs"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#torefs" class="header-anchor">#</a> toRefs</h3> <p>批量解构响应式对象，功能同 <code>toRef</code></p> <h3 id="customref"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#customref" class="header-anchor">#</a> customRef</h3> <p>创建一个自定义的 <code>ref</code>，并对其依赖项跟踪和更新触发进行显式控制。它需要一个工厂函数，该函数接收 <code>track</code> 和 <code>trigger</code> 函数作为参数，并且应该返回一个带有 <code>get</code> 和 <code>set</code> 的对象;</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useDebouncedRef</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> delay <span class="token operator">=</span> <span class="token number">200</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timeout
  <span class="token keyword">return</span> <span class="token function">customRef</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">track<span class="token punctuation">,</span> trigger</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">track</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> value
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token function">set</span><span class="token punctuation">(</span>newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timeout<span class="token punctuation">)</span>
        timeout <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          value <span class="token operator">=</span> newValue
          <span class="token function">trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">text</span><span class="token operator">:</span> <span class="token function">useDebouncedRef</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实意义不大，类似情况应该在我们应该我们的业务层代码去处理，而并非实现一个自定的 <code>ref</code></p> <h3 id="shallowref"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#shallowref" class="header-anchor">#</a> shallowRef</h3> <p>创建一个跟踪自身 .value 变化的 ref，但不会使其值也变成响应式的。类似于 <code>shallowReactive</code>;</p> <h3 id="triggerref"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#triggerref" class="header-anchor">#</a> triggerRef</h3> <p>手动执行与 shallowRef 关联的任何副作用。</p> <h3 id="computed"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#computed" class="header-anchor">#</a> computed</h3> <p><tag>computed</tag> 如果是像 Vue2 那样去使用的话跟 Vue2 中的 <code>computed</code> 没有任何区别；</p> <p>下面来看一下在 <strong><em>setup</em></strong> 函数中如何使用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> computed<span class="token punctuation">,</span> reactive <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vue'</span>

<span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'town'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>name<span class="token punctuation">)</span>

state<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'town2021'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token comment">// town2021</span>

<span class="token comment">// 当然我们还可以创建一个可以修改的计算属性</span>
<span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">computed</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>name<span class="token punctuation">,</span>
  <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token parameter">val</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>name <span class="token operator">===</span> val
<span class="token punctuation">}</span><span class="token punctuation">)</span>

name <span class="token operator">=</span> <span class="token string">'town2020'</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// town2020</span>
</code></pre></div><p>总结一句话，<tag>computed</tag> 接收一个 <code>getter</code> 函数, 并从 <code>getter</code> 返回值中返回一个不变的响应式 <code>ref</code> 对象；</p> <h3 id="watcheffect-watch"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#watcheffect-watch" class="header-anchor">#</a> watchEffect / watch</h3> <p><tag>watchEffect</tag> 监听响应式副作用函数，响应式地跟踪其依赖项时立即运行一个函数，并在更改依赖项时重新运行它。<code>watchEffect</code> 的作用跟 <code>watch</code> 类似；</p> <p>但是也有几点不同：</p> <ol><li><code>watch</code> 惰性执行副作用，<code>watchEffect</code> 会立即执行；</li> <li>更具体地说明应触发侦听器重新运行的状态</li> <li>访问被侦听状态的先前值和当前值</li></ol> <p>第一点在上文已经提到了</p> <p>第二点，大家来看一段代码；</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'town'</span>，
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span>
<span class="token punctuation">}</span>

<span class="token comment">// 并未声明我要监听什么，但是该函数只会监听state.name的变化</span>
<span class="token keyword">const</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 显式的声明了当前watch监听的是state.name</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oval</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> oval<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 其实这段代码也说明了第三点的不同，watch 的回调接收两个参数，一个是state.name的当前状态值，一个是更新之前的值</span>

</code></pre></div><p>现在来看一下 <code>watchEffect</code> 和 <code>watch</code> 都是如何监听多个属性变化的;</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">'town'</span>，
  <span class="token literal-property property">age</span><span class="token operator">:</span> <span class="token number">20</span>
<span class="token punctuation">}</span>

<span class="token comment">// watchEffect 监听多个属性变化，</span>
<span class="token comment">// name 和 age 变化的时候都会触发 watchEffect 的执行</span>
<span class="token keyword">const</span> <span class="token function">watchEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>state<span class="token punctuation">.</span>age <span class="token operator">===</span> <span class="token number">22</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>age<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// watch 监听多个属性变化</span>
<span class="token comment">// 回调函数接收两个数组，分别是监听元素的当前值数组和更新之前的值数组</span>
<span class="token function">watch</span><span class="token punctuation">(</span><span class="token punctuation">[</span>state<span class="token punctuation">.</span>name<span class="token punctuation">,</span> state<span class="token punctuation">.</span>age<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">[</span>name<span class="token punctuation">,</span> age<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>oname<span class="token punctuation">,</span> oage<span class="token punctuation">]</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p><b>问：为什么 watchEffect 不需要显式的声明监听的数据也能正确的监听数据的变化； </b></p> <h2 id="新增组合式-api"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%96%B0%E5%A2%9E%E7%BB%84%E5%90%88%E5%BC%8F-api" class="header-anchor">#</a> 新增组合式 API</h2> <h3 id="setup"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#setup" class="header-anchor">#</a> setup</h3> <p><tag>setup</tag> 函数接受两个参数：</p> <ol><li><code>props</code></li> <li><code>context</code></li></ol> <h3 id="props"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#props" class="header-anchor">#</a> props</h3> <blockquote><p>props: 显式声明在 <code>props</code> 选项中的属性, props 跟 Vue2 中的 props 一样，是响应式的，<strong><em>所以不建议使用 ES6 解构</em></strong>，会消除 props 的响应式；</p></blockquote> <p>如果一定要进行解构且希望保留响应式的话，Vue3 也为我们提供了安全的方法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">props</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> String<span class="token punctuation">,</span>
  <span class="token literal-property property">age</span><span class="token operator">:</span> Number
<span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token function">setup</span> <span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 第一种解构方式</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> name <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>
  <span class="token comment">// 第二种解构方式</span>
  <span class="token keyword">const</span> newProps <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span><span class="token function">toRefs</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token comment">// 第三种解构方式</span>
  <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token function">toRef</span><span class="token punctuation">(</span>props<span class="token punctuation">,</span> <span class="token string">'title'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 这三种解构方式都可保持响应式, 只要是被使用toRefs之后的数据后续无论你再如何进行解构都将保持响应式连接；</span>
<span class="token comment">// 第三种解构方式的主要是为了解决当传入的props中不存在name的情况下，toRefs将不会为name创建一个 ref 对象，</span>
<span class="token comment">// 所以name也就不存在了,后续技术props传入了name，那么我们结构出来的数据也不会是响应式的；</span>

</code></pre></div><p><strong><em>推荐使用第一种解构方式，在 JS 中使用，按需解构；切记请勿将 props 中结构出来的数据使用在模板上</em></strong></p> <p><b>问：如何能让产生了响应式的数据失去响应式?</b></p> <h3 id="context"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#context" class="header-anchor">#</a> context</h3> <blockquote><p>context: 因为在 <code>setup</code> 函数执行的时候，组件实例还未被创建，所以在 <code>context</code> 中仅有 <code>attrs</code>，<code>slots</code>，<code>emit</code> 这三个属性；context 只是一个普通的对象，所以允许解构；</p> <ol><li><code>attrs</code>：父组件传入的属性，非响应式</li> <li><code>slots</code>：当前组件的插槽，非响应式</li> <li><code>emit</code>：触发父组件定义的自定义事件的触发器</li></ol></blockquote> <h3 id="渲染函数"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0" class="header-anchor">#</a> 渲染函数</h3> <p><tag>setup</tag> 支持返回一个渲染函数，<b>渲染函数的内容将替换 template 的内容</b>；该渲染函数可以返回一个 <code>h</code> 函数返回的结果；也可以返回一段 JSX；</p> <p><code>h</code> 函数的渲染</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setup</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'组件'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span> <span class="token string">'h函数的渲染'</span> <span class="token operator">+</span> state<span class="token punctuation">.</span>title<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>jsx</code> 渲染</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setup</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token literal-property property">title</span><span class="token operator">:</span> <span class="token string">'组件'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>jsx渲染<span class="token punctuation">{</span>state<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>推荐使用 JSX 写法，dom 解构，数据逻辑更清晰；</p> <div class="custom-block danger"><p class="custom-block-title">注意</p> <p><code>setup</code> 函数中 <code>this</code> 并非当前活跃实例的引用；如果需要引用当前活跃实例，请使用 <b>getCurrentInstance</b> 函数；</p></div> <h3 id="组合-api-生命周期钩子"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E7%BB%84%E5%90%88-api-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90" class="header-anchor">#</a> 组合 API 生命周期钩子</h3> <h4 id="选项-api-生命周期选项和组合式-api-之间的映射"><a href="http://www.kiscon.top/knowledge/vue2-to-vue3.html#%E9%80%89%E9%A1%B9-api-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%80%89%E9%A1%B9%E5%92%8C%E7%BB%84%E5%90%88%E5%BC%8F-api-%E4%B9%8B%E9%97%B4%E7%9A%84%E6%98%A0%E5%B0%84" class="header-anchor">#</a> 选项 API 生命周期选项和组合式 API 之间的映射</h4> <ol><li><code><s>beforeCreate</s></code> -&gt; 使用 <code>setup()</code></li> <li><code>~~ created~~</code> -&gt; 使用 <code>setup()</code></li> <li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li> <li><code>mounted</code> -&gt; <code>onMounted</code></li> <li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li> <li><code>updated</code> -&gt; <code>onUpdated</code></li> <li><code>beforeUnmount</code> -&gt; <code>onBeforeUnmount</code></li> <li><code>unmounted</code> -&gt; <code>onUnmounted</code></li> <li><code>errorCaptured</code> -&gt; <code>onErrorCaptured</code></li> <li><code>renderTracked</code> -&gt; <code>onRenderTracked</code></li> <li><code>renderTriggered</code> -&gt; <code>onRenderTriggered</code></li> <li><code>activated</code> -&gt; <code>onActivated</code></li> <li><code>deactivated</code>-&gt; <code>onDeactivated</code></li></ol> <auther name="陶文楠" time="2021-08-17"></auther></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="http://www.kiscon.top/knowledge/react.html" class="prev">
        React技术栈
      </a></span> <span class="next"><a href="http://www.kiscon.top/knowledge/webview.html" class="">
        移动web
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    
  

<script>
  const sidebarLinks = document.querySelectorAll('#app > div.theme-container > aside > ul > li:nth-child(1) > section > ul > li > a.sidebar-link');
  sidebarLinks.forEach(item => {
    const href = item.href.split('/').pop();
    item.setAttribute('href', `./${item.textContent}.html`);
  });
</script></body></html>